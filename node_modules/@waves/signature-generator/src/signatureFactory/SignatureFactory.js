"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const __1 = require("..");
const concat_1 = require("../utils/concat");
const crypto_1 = require("../utils/crypto");
const ERRORS = {
    NO_DATA: { code: 'NO_DATA', message: 'No data' },
    FIELD_ERROR: { code: 'FIELD_ERROR', message: 'Invalid field', field: null },
};
function generate(fields) {
    const errors = [];
    if (!fields || !fields.length) {
        errors.push(ERRORS.NO_DATA);
    }
    // Fields of the original data object
    const storedFields = Object.create(null);
    // Data bytes or functions returning data bytes via promises
    const byteProviders = [];
    fields.forEach(function (field) {
        if (field instanceof __1.ByteProcessor) {
            // Remember user data fields
            storedFields[field.name] = field;
            // All user data must be represented as bytes
            byteProviders.push((data) => {
                try {
                    return field.process(data[field.name]);
                }
                catch (e) {
                    throw Object.assign({}, ERRORS.FIELD_ERROR, { field: field.name, message: e.message });
                }
            });
        }
        else if (typeof field === 'number') {
            // All static data must be converted to bytes as well
            byteProviders.push(Uint8Array.from([field]));
        }
        else {
            errors.push(Object.assign({}, ERRORS.FIELD_ERROR, { field }));
        }
    });
    if (errors.length) {
        throw errors;
    }
    class SignatureGenerator {
        constructor(hashMap = {}) {
            this._errors = [];
            // Save all needed values from user data
            this._rawData = Object.keys(storedFields).reduce((store, key) => {
                store[key] = hashMap[key];
                return store;
            }, {});
            this._dataHolders = byteProviders.map((provider) => {
                if (typeof provider === 'function') {
                    // Execute function so that they return promises containing Uint8Array data
                    try {
                        return provider(this._rawData);
                    }
                    catch (e) {
                        this._errors.push(e);
                    }
                }
                else {
                    // Or just pass Uint8Array data
                    return provider;
                }
            });
            if (this._errors.length) {
                throw this._errors;
            }
        }
        getSignature(privateKey) {
            return this.getBytes().then((dataBytes) => {
                return crypto_1.default.buildTransactionSignature(dataBytes, privateKey);
            });
        }
        // Get byte representation of the transaction
        getBytes() {
            return Promise.all(this._dataHolders).then((multipleDataBytes) => {
                if (multipleDataBytes.length === 1) {
                    return multipleDataBytes[0];
                }
                else {
                    return concat_1.concatUint8Arrays(...multipleDataBytes);
                }
            });
        }
        getDebugBytes() {
            return Promise.all(fields.map((field, i) => {
                const value = field && field.name ? this._rawData[field.name] : null;
                const result = this._dataHolders[i];
                if (result instanceof Promise) {
                    return result.then(bytes => {
                        return { bytes, from: field && field.name || field, value };
                    });
                }
                else {
                    return Promise.resolve({ bytes: result, from: field, value });
                }
            }));
        }
        // Get bytes of an exact field from user data
        getExactBytes(fieldName) {
            if (!(fieldName in storedFields)) {
                throw new Error(`There is no field '${fieldName}' in 'RequestDataType class`);
            }
            const byteProcessor = storedFields[fieldName];
            const userData = this._rawData[fieldName];
            return byteProcessor.process(userData);
        }
    }
    return SignatureGenerator;
}
exports.generate = generate;
exports.TX_NUMBER_MAP = Object.create(null);
exports.TX_TYPE_MAP = Object.create(null);
exports.CREATE_ORDER_SIGNATURE = generate([
    new __1.Base58('senderPublicKey'),
    new __1.Base58('matcherPublicKey'),
    new __1.AssetId('amountAsset'),
    new __1.AssetId('priceAsset'),
    new __1.OrderType('orderType'),
    new __1.Long('price'),
    new __1.Long('amount'),
    new __1.Long('timestamp'),
    new __1.Long('expiration'),
    new __1.Long('matcherFee')
]);
exports.AUTH_ORDER_SIGNATURE = generate([
    new __1.Base58('senderPublicKey'),
    new __1.Long('timestamp')
]);
exports.CANCEL_ORDER_SIGNATURE = generate([
    new __1.Base58('senderPublicKey'),
    new __1.Base58('orderId')
]);
const ISSUE = generate([
    3 /* ISSUE */,
    2 /* ISSUE */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.StringWithLength('name'),
    new __1.StringWithLength('description'),
    new __1.Long('quantity'),
    new __1.Byte('precision'),
    new __1.Bool('reissuable'),
    new __1.Long('fee'),
    new __1.Long('timestamp'),
    0 // Byte for script smart assets.
]);
exports.TX_NUMBER_MAP[3 /* ISSUE */] = ISSUE;
exports.TX_TYPE_MAP["issue" /* ISSUE */] = ISSUE;
const TRANSFER = generate([
    4 /* TRANSFER */,
    2 /* TRANSFER */,
    new __1.Base58('senderPublicKey'),
    new __1.AssetId('assetId'),
    new __1.AssetId('feeAssetId'),
    new __1.Long('timestamp'),
    new __1.Long('amount'),
    new __1.Long('fee'),
    new __1.Recipient('recipient'),
    new __1.Attachment('attachment')
]);
exports.TX_NUMBER_MAP[4 /* TRANSFER */] = TRANSFER;
exports.TX_TYPE_MAP["transfer" /* TRANSFER */] = TRANSFER;
const REISSUE = generate([
    5 /* REISSUE */,
    2 /* REISSUE */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.MandatoryAssetId('assetId'),
    new __1.Long('quantity'),
    new __1.Bool('reissuable'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[5 /* REISSUE */] = REISSUE;
exports.TX_TYPE_MAP["reissue" /* REISSUE */] = REISSUE;
const BURN = generate([
    6 /* BURN */,
    2 /* BURN */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.MandatoryAssetId('assetId'),
    new __1.Long('quantity'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[6 /* BURN */] = BURN;
exports.TX_TYPE_MAP["burn" /* BURN */] = BURN;
const LEASE = generate([
    8 /* LEASE */,
    2 /* LEASE */,
    0,
    new __1.Base58('senderPublicKey'),
    new __1.Recipient('recipient'),
    new __1.Long('amount'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[8 /* LEASE */] = LEASE;
exports.TX_TYPE_MAP["lease" /* LEASE */] = LEASE;
const CANCEL_LEASING = generate([
    9 /* CANCEL_LEASING */,
    2 /* CANCEL_LEASING */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.Long('fee'),
    new __1.Long('timestamp'),
    new __1.Base58('transactionId')
]);
exports.TX_NUMBER_MAP[9 /* CANCEL_LEASING */] = CANCEL_LEASING;
exports.TX_TYPE_MAP["cancelLeasing" /* CANCEL_LEASING */] = CANCEL_LEASING;
const CREATE_ALIAS = generate([
    10 /* CREATE_ALIAS */,
    2 /* CREATE_ALIAS */,
    new __1.Base58('senderPublicKey'),
    new __1.Alias('alias'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[10 /* CREATE_ALIAS */] = CREATE_ALIAS;
exports.TX_TYPE_MAP["createAlias" /* CREATE_ALIAS */] = CREATE_ALIAS;
const MASS_TRANSFER = generate([
    11 /* MASS_TRANSFER */,
    1 /* MASS_TRANSFER */,
    new __1.Base58('senderPublicKey'),
    new __1.AssetId('assetId'),
    new __1.Transfers('transfers'),
    new __1.Long('timestamp'),
    new __1.Long('fee'),
    new __1.Attachment('attachment')
]);
exports.TX_NUMBER_MAP[11 /* MASS_TRANSFER */] = MASS_TRANSFER;
exports.TX_TYPE_MAP["massTransfer" /* MASS_TRANSFER */] = MASS_TRANSFER;
const DATA = generate([
    12 /* DATA */,
    1 /* DATA */,
    new __1.Base58('senderPublicKey'),
    new __1.DataEntries('data'),
    new __1.Long('timestamp'),
    new __1.Long('fee')
]);
exports.TX_NUMBER_MAP[12 /* DATA */] = DATA;
exports.TX_TYPE_MAP["data" /* DATA */] = DATA;
const SET_SCRIPT = generate([
    13 /* SET_SCRIPT */,
    1 /* SET_SCRIPT */,
    new __1.Byte('chainId'),
    new __1.Base58('senderPublicKey'),
    new __1.ScriptVersion('script'),
    new __1.Base64('script'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[13 /* SET_SCRIPT */] = SET_SCRIPT;
exports.TX_TYPE_MAP["setScript" /* SET_SCRIPT */] = SET_SCRIPT;
const SPONSORSHIP = generate([
    14 /* SPONSORSHIP */,
    1 /* SPONSORSHIP */,
    new __1.Base58('senderPublicKey'),
    new __1.Base58('assetId'),
    new __1.Long('minSponsoredAssetFee'),
    new __1.Long('fee'),
    new __1.Long('timestamp')
]);
exports.TX_NUMBER_MAP[14 /* SPONSORSHIP */] = SPONSORSHIP;
exports.TX_TYPE_MAP["sponsorship" /* SPONSORSHIP */] = SPONSORSHIP;
