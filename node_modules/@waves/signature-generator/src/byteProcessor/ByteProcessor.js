"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const data_entities_1 = require("@waves/data-entities");
const base64_js_1 = require("base64-js");
const base58_1 = require("../libs/base58");
const convert_1 = require("../utils/convert");
const concat_1 = require("../utils/concat");
const constants_1 = require("../constants");
const __1 = require("..");
const constants_2 = require("../constants");
// NOTE : Waves asset ID in blockchain transactions equals to an empty string
function blockchainifyAssetId(assetId) {
    if (!assetId)
        throw new Error('Asset ID should not be empty');
    return assetId === constants_2.WAVES_ID ? constants_2.WAVES_BLOCKCHAIN_ID : assetId;
}
function getAliasBytes(alias) {
    const aliasBytes = convert_1.default.stringToByteArrayWithSize(alias);
    return [constants_2.ALIAS_VERSION, __1.config.getNetworkByte(), ...aliasBytes];
}
function isNonEmptyBase64String(value) {
    const pure = value.replace('base64:', '');
    return pure.length > 0 && pure.length % 4 === 0;
}
// ABSTRACT PARENT
class ByteProcessor {
    constructor(name) {
        this.name = name;
    }
}
exports.ByteProcessor = ByteProcessor;
// SIMPLE
class Base58 extends ByteProcessor {
    process(value) {
        const bytes = base58_1.default.decode(value);
        return Promise.resolve(bytes);
    }
}
exports.Base58 = Base58;
class Base64 extends ByteProcessor {
    process(value) {
        if (typeof value !== 'string')
            throw new Error('You should pass a string to BinaryDataEntry constructor');
        if (isNonEmptyBase64String(value)) {
            if (value.slice(0, 7) !== 'base64:')
                throw new Error('Blob should be encoded in base64 and prefixed with "base64:"');
            const b64 = value.slice(7); // Getting the string payload
            const bytes = Uint8Array.from(base64_js_1.toByteArray(b64));
            const lengthBytes = Uint8Array.from(convert_1.default.shortToByteArray(bytes.length));
            return Promise.resolve(concat_1.concatUint8Arrays(lengthBytes, bytes));
        }
        else {
            return Promise.resolve(Uint8Array.from([]));
        }
    }
}
exports.Base64 = Base64;
class Bool extends ByteProcessor {
    process(value) {
        const bytes = convert_1.default.booleanToBytes(value);
        return Promise.resolve(Uint8Array.from(bytes));
    }
}
exports.Bool = Bool;
class Byte extends ByteProcessor {
    process(value) {
        if (typeof value !== 'number')
            throw new Error('You should pass a number to Byte constructor');
        if (value < 0 || value > 255)
            throw new Error('Byte value must fit between 0 and 255');
        return Promise.resolve(Uint8Array.from([value]));
    }
}
exports.Byte = Byte;
class Long extends ByteProcessor {
    process(value) {
        let bytes;
        if (typeof value === 'number') {
            bytes = convert_1.default.longToByteArray(value);
        }
        else {
            if (typeof value === 'string') {
                value = new data_entities_1.BigNumber(value);
            }
            bytes = convert_1.default.bigNumberToByteArray(value);
        }
        return Promise.resolve(Uint8Array.from(bytes));
    }
}
exports.Long = Long;
class Short extends ByteProcessor {
    process(value) {
        if (typeof value !== 'number')
            throw new Error('You should pass a number to Short constructor');
        if (value < 0 || value > 65535)
            throw new Error('Short value must fit between 0 and 65535');
        return Promise.resolve(Uint8Array.from(convert_1.default.shortToByteArray(value)));
    }
}
exports.Short = Short;
class StringWithLength extends ByteProcessor {
    process(value) {
        const bytesWithLength = convert_1.default.stringToByteArrayWithSize(value);
        return Promise.resolve(Uint8Array.from(bytesWithLength));
    }
}
exports.StringWithLength = StringWithLength;
// COMPLEX
class Alias extends ByteProcessor {
    process(value) {
        const aliasBytes = getAliasBytes(value);
        const aliasBytesWithLength = convert_1.default.bytesToByteArrayWithSize(aliasBytes);
        return Promise.resolve(Uint8Array.from(aliasBytesWithLength));
    }
}
exports.Alias = Alias;
class AssetId extends ByteProcessor {
    process(value) {
        value = blockchainifyAssetId(value);
        // We must pass bytes of `[0]` for Waves asset ID and bytes of `[1] + assetId` for other asset IDs
        const bytes = value ? concat_1.concatUint8Arrays(Uint8Array.from([1]), base58_1.default.decode(value)) : Uint8Array.from([0]);
        return Promise.resolve(bytes);
    }
}
exports.AssetId = AssetId;
class Attachment extends ByteProcessor {
    process(value) {
        if (typeof value === 'string') {
            value = Uint8Array.from(convert_1.default.stringToByteArray(value));
        }
        if (value.length > constants_2.TRANSFER_ATTACHMENT_BYTE_LIMIT) {
            throw new Error('Maximum attachment length is exceeded');
        }
        const valueWithLength = convert_1.default.bytesToByteArrayWithSize(value);
        return Promise.resolve(Uint8Array.from(valueWithLength));
    }
}
exports.Attachment = Attachment;
class MandatoryAssetId extends ByteProcessor {
    process(value) {
        value = blockchainifyAssetId(value);
        return Promise.resolve(base58_1.default.decode(value));
    }
}
exports.MandatoryAssetId = MandatoryAssetId;
class OrderType extends ByteProcessor {
    process(value) {
        if (value === 'buy') {
            return Bool.prototype.process.call(this, false);
        }
        else if (value === 'sell') {
            return Bool.prototype.process.call(this, true);
        }
        else {
            throw new Error('There are no other order types besides "buy" and "sell"');
        }
    }
}
exports.OrderType = OrderType;
class Recipient extends ByteProcessor {
    process(value) {
        if (value.length <= 30) {
            const aliasBytes = getAliasBytes(value);
            return Promise.resolve(Uint8Array.from(aliasBytes));
        }
        else {
            const addressBytes = base58_1.default.decode(value);
            return Promise.resolve(Uint8Array.from(addressBytes));
        }
    }
}
exports.Recipient = Recipient;
class ScriptVersion extends ByteProcessor {
    process(value) {
        if (isNonEmptyBase64String(value)) {
            return Promise.resolve(Uint8Array.from([constants_1.SET_SCRIPT_LANG_VERSION]));
        }
        else {
            return Promise.resolve(Uint8Array.from([0]));
        }
    }
}
exports.ScriptVersion = ScriptVersion;
class Transfers extends ByteProcessor {
    process(values) {
        const recipientProcessor = new Recipient(constants_1.STUB_NAME);
        const amountProcessor = new Long(constants_1.STUB_NAME);
        const promises = [];
        for (let i = 0; i < values.length; i++) {
            promises.push(recipientProcessor.process(values[i].recipient));
            promises.push(amountProcessor.process(values[i].amount));
        }
        return Promise.all(promises).then((elements) => {
            const length = convert_1.default.shortToByteArray(values.length);
            const lengthBytes = Uint8Array.from(length);
            return concat_1.concatUint8Arrays(lengthBytes, ...elements);
        });
    }
}
exports.Transfers = Transfers;
// DATA TRANSACTIONS ONLY
const INTEGER_DATA_TYPE = 0;
const BOOLEAN_DATA_TYPE = 1;
const BINARY_DATA_TYPE = 2;
const STRING_DATA_TYPE = 3;
class IntegerDataEntry extends ByteProcessor {
    process(value) {
        return Long.prototype.process.call(this, value).then((longBytes) => {
            const typeByte = Uint8Array.from([INTEGER_DATA_TYPE]);
            return concat_1.concatUint8Arrays(typeByte, longBytes);
        });
    }
}
exports.IntegerDataEntry = IntegerDataEntry;
class BooleanDataEntry extends ByteProcessor {
    process(value) {
        return Bool.prototype.process.call(this, value).then((boolByte) => {
            const typeByte = Uint8Array.from([BOOLEAN_DATA_TYPE]);
            return concat_1.concatUint8Arrays(typeByte, boolByte);
        });
    }
}
exports.BooleanDataEntry = BooleanDataEntry;
class BinaryDataEntry extends ByteProcessor {
    process(value) {
        return Base64.prototype.process.call(this, value).then((binaryBytes) => {
            const typeByte = Uint8Array.from([BINARY_DATA_TYPE]);
            return Promise.resolve(concat_1.concatUint8Arrays(typeByte, binaryBytes));
        });
    }
}
exports.BinaryDataEntry = BinaryDataEntry;
class StringDataEntry extends ByteProcessor {
    process(value) {
        return StringWithLength.prototype.process.call(this, value).then((stringBytes) => {
            const typeByte = Uint8Array.from([STRING_DATA_TYPE]);
            return concat_1.concatUint8Arrays(typeByte, stringBytes);
        });
    }
}
exports.StringDataEntry = StringDataEntry;
class DataEntries extends ByteProcessor {
    process(entries) {
        const lengthBytes = Uint8Array.from(convert_1.default.shortToByteArray(entries.length));
        if (entries.length) {
            return Promise.all(entries.map((entry) => {
                const prependKeyBytes = (valueBytes) => {
                    return StringWithLength.prototype.process.call(this, entry.key).then((keyBytes) => {
                        return concat_1.concatUint8Arrays(keyBytes, valueBytes);
                    });
                };
                switch (entry.type) {
                    case 'integer':
                        return IntegerDataEntry.prototype.process.call(this, entry.value).then(prependKeyBytes);
                    case 'boolean':
                        return BooleanDataEntry.prototype.process.call(this, entry.value).then(prependKeyBytes);
                    case 'binary':
                        return BinaryDataEntry.prototype.process.call(this, entry.value).then(prependKeyBytes);
                    case 'string':
                        return StringDataEntry.prototype.process.call(this, entry.value).then(prependKeyBytes);
                    default:
                        throw new Error(`There is no data type "${entry.type}"`);
                }
            })).then((entriesBytes) => {
                const bytes = concat_1.concatUint8Arrays(lengthBytes, ...entriesBytes);
                if (bytes.length > constants_1.DATA_ENTRIES_BYTE_LIMIT)
                    throw new Error('Data transaction is too large (140KB max)');
                return bytes;
            });
        }
        else {
            return Promise.resolve(Uint8Array.from([0, 0]));
        }
    }
}
exports.DataEntries = DataEntries;
